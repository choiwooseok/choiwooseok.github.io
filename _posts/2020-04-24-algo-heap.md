---
title: "Heap"
date: 2020-04-24 00:00:00 -0400
categories: algorithm
---

* 힙 : 완전 이진트리, 가장 낮은 레벨을 빼고는 차있고 가장 낮은 레벨은 왼쪽부터
* 0 <= A.heap-size(힙에 속하는 원소의 갯수) <= A.length (배열의 원소의 갯수)

* MAX Heap
  * 임의의 노드값은 부모값보다 클 수 없다. A[PARENT(i)] >= A(i)

* MIN Heap
  * root가 최소값이다. A[PARENT(i)] <= A[i]

* 원소의 갯수가 n개 인 힙을 배열로 나타내면 n/2 + 1 ... n 번째 노드는 리프노드

* 힙 특성 유지

```cpp
#include <iostream>
#include <vector>

template<typename T>
void printVector(std::vector<T>& arr) {
    for(T& elem : arr) {
        std::cout << elem << " ";
    }
    std::cout << std::endl;
}

int parent(int i) {
    return (i - 1)/2;
}

int left(int i) {
    return 2*i + 1;
} 
  
int right(int i) {
    return 2*i + 2;
} 

// MAX-HEAPIFY
// l = LEFT(i)
// r = RIGHT(i)
// if l <= A.heap-size and A[l] > A[i]
//     largest = l
// else
//     largest = i
// if r <= A.heap-size and A[r] > A[largest]
//     largest = r
// if largest != i
//     exchange A[i] with A[largest]
//     MAX-HEAPIFY(A, largest)
void max_heapify(std::vector<int>& arr, int idx) {
    int largest = 0;
    int l = left(idx);
    int r = right(idx);

    if (l <= arr.size() && arr[l] > arr[idx]) {
        largest = l;
    } else {
        largest = idx;
    }

    if (r <= arr.size() && arr[r] > arr[largest]) {
        largest = r;
    }
    if(largest != idx) {
        std::cout << arr[idx] << " " << arr[largest] << " swaped" << std::endl;
        std::swap(arr[idx], arr[largest]); 
        max_heapify(arr, largest);
    }
}

int main(int argc, char** argv) {

    std::vector<int> arr = {16, 4, 10, 14, 7, 9, 3, 2, 8, 1};
    max_heapify(arr, 1);

//          16(0)
//        /       \
//     4(1)       10(2)
//    /   \       /    \
//  14(3)  7(4)  9(5)  3(6)
// /   \    / 
//2(7) 8(8) 1(9)

//          16(0)
//        /       \
//     14(1)       10(2)
//    /   \       /    \
//  4(3)  7(4)  9(5)  3(6)
// /   \    / 
//2(7) 8(8) 1(9)

//          16(0)
//        /       \
//     14(1)       10(2)
//    /   \       /    \
//  8(3)  7(4)  9(5)  3(6)
// /   \    / 
//2(7) 4(8) 1(9)

    printVector(arr);

    return 0;
}
```

* TODO
