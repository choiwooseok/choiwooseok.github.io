---
title: "bfs codewars Path Finder #1: can you reach the exit?"
date: 2020-04-12 00:00:00 -0400
categories: algorithm
---

```cpp
#include <iostream>
#include <string>
#include <queue>
#include <vector>
#include <array>
using namespace std;

std::array<std::pair<int,int>, 4> directions = {
  std::make_pair(-1,  0),
  std::make_pair( 1,  0),
  std::make_pair( 0, -1),
  std::make_pair( 0,  1)
}; 

class Node {
public:
  std::pair<int, int> pos;
  int dist;
public:
  Node(std::pair<int,int> pos, int dist) : pos(pos), dist(dist) {}
};

bool isValid(int row, int col, int x, int y) {
  return x >= 0 && x < row && y >= 0 && y < col;
}

bool bfs(std::vector<std::vector<char> >& map, std::pair<int,int> src, std::pair<int,int> dst) {
  int n = map.size();
  int m = map.front().size();
  if(map[src.first][src.second] == 'W' || map[dst.first][dst.second] == 'W') {
    return false;
  }
  std::vector<std::vector<bool> > visited(n, std::vector<bool>(n, false));
  visited[src.first][src.second] = true;
  
  std::queue<Node> q;
  q.push(Node(src, 0));
  
  while(!q.empty()) {
    Node curr = q.front();
    std::pair<int, int> pos = curr.pos;
    if(pos == dst) {
      return true;
    }
    q.pop();
    for(auto& direction : directions) {
      int nextX = pos.first + direction.first;
      int nextY = pos.second + direction.second;
      if(isValid(n, m, nextX, nextY) 
          && map[nextX][nextY] != 'W' 
          && !visited[nextX][nextY]) {

        visited[nextX][nextY] = true;
        Node adj(std::make_pair(nextX, nextY), curr.dist + 1);
        q.push(adj);
      }
    }
  }
  return false;
}

bool path_finder(string maze) {
  int n = std::count(maze.begin(), maze.end(), '\n') + 1;
  std::vector<std::vector<char> > map(n, std::vector<char>(n, '.'));
  int i = 0;
  int j = 0;
  for(char ch : maze) {
    if(ch == '\n') {
      j++;
      i = 0;
    } else {
      map[i][j] = ch;
      i++;
    }
  }
  
  return bfs(map, {0,0}, {n-1, n-1});
}
```